<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>DreamPlay ‚Äî Day Hub</title>

  <!-- optional favicon to stop 404 -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E%F0%9F%8E%B5%3C/text%3E%3C/svg%3E">

  <style>
    :root{
      --bg:#0b0f19; --card:rgba(255,255,255,.06); --stroke:rgba(255,255,255,.12);
      --text:#e8eefc; --muted:rgba(232,238,252,.72);
      --good:#7CFC9A; --bad:#ff9aa2; --accent:#6ee7ff;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:var(--bg);color:var(--text)}
    .wrap{max-width:1040px;margin:0 auto;padding:22px}
    .top{display:flex;gap:12px;flex-wrap:wrap;align-items:flex-end;justify-content:space-between}
    h1{margin:0;font-size:22px}
    .muted{color:var(--muted)}
    .card{background:var(--card);border:1px solid var(--stroke);border-radius:16px;padding:16px;margin:14px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){.grid2{grid-template-columns:1fr}}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.08);font-size:12px}
    .dot{width:8px;height:8px;border-radius:999px;background:rgba(255,255,255,.35)}
    .dot.good{background:var(--good)}
    .dot.bad{background:var(--bad)}
    button{cursor:pointer;border:0;border-radius:12px;padding:10px 12px;font-weight:800}
    .primary{background:var(--accent);color:#071019}
    .secondary{background:rgba(255,255,255,.12);color:var(--text);border:1px solid rgba(255,255,255,.18)}
    input,select{background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.18);color:var(--text);border-radius:12px;padding:10px 12px}
    pre{margin:10px 0 0;background:rgba(0,0,0,.25);border:1px solid var(--stroke);border-radius:12px;padding:12px;white-space:pre-wrap;word-break:break-word;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px}
    a{color:var(--accent)}
    .task h3{margin:0 0 6px;font-size:16px}
    .task p{margin:0;color:var(--muted);font-size:13px;line-height:1.35}
    .task .actions{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end}
    #confetti{position:fixed;inset:0;pointer-events:none;overflow:hidden;display:none}
    .c{position:absolute;top:-10px;width:10px;height:14px;opacity:.95}
    code{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px}
  </style>
</head>
<body>
  <div id="confetti"></div>

  <div class="wrap">
    <div class="top">
      <div>
        <h1>DreamPlay ‚Äî Day Hub</h1>
        <div class="muted">One screen. Same order every day: üå± PNR ‚Üí üîÅ Buy ‚Üí üíß Liquidity. All green = confetti + Kept Today.</div>
      </div>
      <div class="row">
        <span class="pill"><span class="dot" id="dotWallet"></span> Wallet: <span id="addrLabel">‚Äî</span></span>
        <span class="pill"><span class="dot" id="dotNet"></span> Chain: <span id="netLabel">‚Äî</span></span>
        <span class="pill"><span class="dot good"></span> UTC dayId: <span id="dayLabel">‚Äî</span></span>
        <span class="pill"><span class="dot" id="dotKept"></span> Kept Today: <span id="keptLabel">‚Äî</span></span>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <strong>Wallet</strong>
        <div class="row">
          <button class="secondary" id="btnConnect">Connect MetaMask</button>
          <button class="secondary" id="btnResetDay">Reset local receipts</button>
        </div>
      </div>
      <div class="muted" style="margin-top:8px">Tip: open the live Netlify URL (https). MetaMask won‚Äôt connect from a local <code>file://</code> page.</div>
      <pre id="log"></pre>
    </div>

    <div class="card">
      <strong>Step 1 ‚Äî üå± PNR (Watch)</strong>
      <div class="muted" style="margin-top:6px">
        Uses the <b>new on-chain format</b>: Netlify signs a digest, then we call
        <code>claim(dayId, videoIdBytes32, expiresAt, sig)</code>.
      </div>

      <div class="grid2" style="margin-top:12px">
        <div class="card" style="margin:0">
          <div class="task">
            <div>
              <div class="row" style="justify-content:space-between">
                <h3 style="margin:0">Claim PNR</h3>
                <span class="pill"><span class="dot" id="dotPNR"></span> <span id="pnrLabel">‚Äî</span></span>
              </div>
              <p>Click claim after you‚Äôve watched. The claim tx is the proof (on-chain <code>PnrReceiptOk</code>).</p>
              <div class="muted" style="margin-top:10px">
                Expiry seconds (60‚Äì3600):
                <input id="expInput" value="900" inputmode="numeric" style="width:120px"/>
              </div>
            </div>
            <div class="actions">
              <button class="primary" id="btnPnrClaim" disabled>I Watched Today (Claim)</button>
              <button class="secondary" id="btnPnrCheck" disabled>Check last</button>
            </div>
          </div>
          <div class="muted" style="margin-top:10px">Last PNR tx: <span id="pnrTx">‚Äî</span></div>
        </div>

        <div class="card" style="margin:0">
          <div class="task">
            <div>
              <h3 style="margin:0 0 6px">PNR turns green when‚Ä¶</h3>
              <p>The tx confirms, and the receipt contains <code>PnrReceiptOk(address,uint32,bytes32)</code> with topic1 == your wallet.</p>
              <p class="muted" style="margin-top:8px">If you see <code>DAYID_MISMATCH</code>, the signer payload dayId didn‚Äôt match your client dayId (off-by-one protection).</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <strong>Step 2 ‚Äî üîÅ Buy through BuyHelper</strong>
      <div class="muted" style="margin-top:6px">Verify by reading receipt logs from your buy tx. Auto-verify uses Polygonscan (optional key).</div>

      <div class="grid2" style="margin-top:12px">
        <div class="card" style="margin:0">
          <div class="task">
            <div>
              <div class="row" style="justify-content:space-between">
                <h3 style="margin:0">Buy status</h3>
                <span class="pill"><span class="dot" id="dotBuy"></span> <span id="buyLabel">‚Äî</span></span>
              </div>
              <div class="row" style="margin-top:10px">
                <button class="secondary" id="btnBuyOpen">Open BuyHelper</button>
                <button class="secondary" id="btnBuyAuto" disabled>Auto-Verify Today</button>
              </div>
              <div class="muted" style="margin-top:10px">Paste buy tx hash:</div>
              <div class="row" style="margin-top:8px">
                <input id="buyTxInput" placeholder="0x..." style="flex:1;min-width:240px"/>
                <button class="primary" id="btnBuyCheck" disabled>Check Tx</button>
              </div>
              <div class="muted" style="margin-top:10px">Last buy tx: <span id="buyTx">‚Äî</span></div>
            </div>
          </div>
        </div>

        <div class="card" style="margin:0">
          <div class="task">
            <div>
              <h3 style="margin:0 0 6px">Buy verification rule</h3>
              <p>We look for a receipt log matching <code id="buyEventLabel"></code> (topic0) and your wallet (topic1).</p>
              <p class="muted" style="margin-top:8px">If you don't use Polygonscan key, paste tx hash and click ‚ÄúCheck Tx‚Äù.</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <strong>Step 3 ‚Äî üíß Liquidity (Ad Liquidity)</strong>
      <div class="muted" style="margin-top:6px">Verify by finding <code>HubReceiptOk(address)</code> in your deposit tx receipt logs.</div>

      <div class="grid2" style="margin-top:12px">
        <div class="card" style="margin:0">
          <div class="task">
            <div>
              <div class="row" style="justify-content:space-between">
                <h3 style="margin:0">Liquidity status</h3>
                <span class="pill"><span class="dot" id="dotLiq"></span> <span id="liqLabel">‚Äî</span></span>
              </div>
              <div class="row" style="margin-top:10px">
                <button class="secondary" id="btnLiqOpen">Open Liquidity App</button>
                <button class="secondary" id="btnLiqAuto" disabled>Auto-Verify Today</button>
              </div>
              <div class="muted" style="margin-top:10px">Paste deposit tx hash:</div>
              <div class="row" style="margin-top:8px">
                <input id="liqTxInput" placeholder="0x..." style="flex:1;min-width:240px"/>
                <button class="primary" id="btnLiqCheck" disabled>Check Tx</button>
              </div>
              <div class="muted" style="margin-top:10px">Last liquidity tx: <span id="liqTx">‚Äî</span></div>
            </div>
          </div>
        </div>

        <div class="card" style="margin:0">
          <div class="task">
            <div>
              <h3 style="margin:0 0 6px">Liquidity verification rule</h3>
              <p>We look for <code>HubReceiptOk(address)</code> (topic0) and your wallet (topic1).</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <strong>Permanent ‚Äî Register your support to a Rhythm</strong>
      <div class="muted" style="margin-top:6px">Stored in your browser per wallet (upgrade to on-chain later).</div>

      <div class="row" style="margin-top:12px;justify-content:space-between">
        <div class="row" style="gap:12px">
          <select id="rhythmSelect">
            <option value="Rhythm: Watch + Claim">Rhythm: Watch + Claim</option>
            <option value="Rhythm: BuyHelper">Rhythm: BuyHelper</option>
            <option value="Rhythm: Add Liquidity">Rhythm: Add Liquidity</option>
            <option value="Rhythm: All Three Daily">Rhythm: All Three Daily</option>
          </select>
          <button class="primary" id="btnSaveSupport" disabled>Save Support</button>
        </div>
        <span class="pill"><span class="dot" id="dotSupport"></span> <span id="supportLabel">‚Äî</span></span>
      </div>
    </div>

    <div class="card">
      <strong>Config</strong>
      <div class="muted" style="margin-top:6px">Edit constants in the script if addresses/event names change.</div>
      <pre id="cfg"></pre>
    </div>
  </div>

  <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script>
    /**********************
     * CONFIG (EDIT ME)
     **********************/
    const CONFIG = {
      CHAIN_ID: 137,
      CHAIN_HEX: "0x89",

      // DreamPlayPNRClaimer_V2 address
      PNR_CONTRACT: "0xcB819189dD53FA65b5b15E979b5D6715752Acef9",
      SIGN_ENDPOINT: "/.netlify/functions/pnr-sign",

      // Convenience links (replace with real URLs)
      BUYHELPER_URL: "https://dreamplay-rhythm-chain.netlify.app/",
      LIQUIDITY_URL: "https://dreamplay-rhythm-chain.netlify.app/",

      // Receipt checks (RPC)
      RPC_URL: "https://polygon-rpc.com",

      // Optional Polygonscan key for auto-verify. If empty, auto-verify buttons stay disabled.
      POLYGONSCAN_API_KEY: "TG2IUX9DQ5Q31IUXVTC481DHFVCYQ9NI15",

      // Event signatures (topic0)
      HUB_RECEIPT_EVENT: "HubReceiptOk(address)",
      BUY_RECEIPT_EVENT: "Week1BuyReceiptOk(address)",

      // PNR receipt event (from your contract)
      PNR_RECEIPT_EVENT: "PnrReceiptOk(address,uint32,bytes32)"
    };

    // ABI for DreamPlayPNRClaimer_V2
    const PNR_ABI = [
      "function claim(uint32 dayId, bytes32 videoId, uint64 expiresAt, bytes sig) external returns (bytes32)"
    ];

    /**********************
     * Helpers
     **********************/
    const logEl = document.getElementById("log");
    function logLine(...args){
      const s = args.map(a => typeof a === "string" ? a : JSON.stringify(a, null, 2)).join(" ");
      logEl.textContent = (logEl.textContent ? logEl.textContent + "\n" : "") + s;
      logEl.scrollTop = logEl.scrollHeight;
    }
    function utcDayIdNow(){ return Math.floor(Math.floor(Date.now()/1000)/86400); }
    function setDot(id, val){
      const el = document.getElementById(id);
      el.classList.remove("good","bad");
      if (val === true) el.classList.add("good");
      if (val === false) el.classList.add("bad");
    }
    function setText(id, s){ document.getElementById(id).textContent = s; }

    // local storage (daily)
    function keyDay(wallet, dayId){ return `dp:dayhub:${(wallet||"anon").toLowerCase()}:day:${dayId}`; }
    function getDayState(wallet, dayId){
      try { return JSON.parse(localStorage.getItem(keyDay(wallet, dayId)) || "{}"); } catch { return {}; }
    }
    function setDayState(wallet, dayId, patch){
      const prev = getDayState(wallet, dayId);
      const next = Object.assign(
        { pnr:false, buy:false, liq:false, confetti:false, pnrTx:"", buyTx:"", liqTx:"" },
        prev,
        patch
      );
      localStorage.setItem(keyDay(wallet, dayId), JSON.stringify(next));
      return next;
    }

    // permanent support
    function keySupport(wallet){ return `dp:support:${(wallet||"anon").toLowerCase()}`; }
    function getSupport(wallet){ try { return JSON.parse(localStorage.getItem(keySupport(wallet)) || "null"); } catch { return null; } }
    function setSupport(wallet, value){ localStorage.setItem(keySupport(wallet), JSON.stringify({ value, ts: Date.now() })); }

    // confetti (no external libs)
    function confettiOnce(){
      const root = document.getElementById("confetti");
      root.innerHTML = "";
      root.style.display = "block";
      const W = window.innerWidth;
      const colors = ["#6ee7ff","#7CFC9A","#ffd166","#ff9aa2","#cdb4ff","#a7f3d0"];
      for(let i=0;i<120;i++){
        const d = document.createElement("div");
        d.className = "c";
        d.style.left = (Math.random()*W) + "px";
        d.style.background = colors[Math.floor(Math.random()*colors.length)];
        d.style.opacity = (0.6 + Math.random()*0.4).toFixed(2);
        d.style.width = (6 + Math.random()*8).toFixed(0) + "px";
        d.style.height = (8 + Math.random()*10).toFixed(0) + "px";
        d.dataset.v = (2 + Math.random()*5).toFixed(2);
        d.dataset.w = (-1 + Math.random()*2).toFixed(2);
        root.appendChild(d);
      }
      let t = 0;
      const tick = () => {
        t += 1;
        for(const d of root.children){
          const v = parseFloat(d.dataset.v);
          const w = parseFloat(d.dataset.w);
          const top = (parseFloat(d.style.top||"-10") + v);
          const left = (parseFloat(d.style.left) + w);
          d.style.top = top + "px";
          d.style.left = left + "px";
        }
        if (t < 160) requestAnimationFrame(tick);
        else root.style.display = "none";
      };
      requestAnimationFrame(tick);
    }

    /**********************
     * Wallet / Providers
     **********************/
    let provider, signer, userAddr;
    let rpcProvider;

    async function ensurePolygon(){
      const net = await provider.getNetwork();
      setText("netLabel", String(net.chainId));
      setDot("dotNet", net.chainId === CONFIG.CHAIN_ID);
      if (net.chainId === CONFIG.CHAIN_ID) return true;
      try{
        await window.ethereum.request({ method:"wallet_switchEthereumChain", params:[{ chainId: CONFIG.CHAIN_HEX }] });
        const net2 = await provider.getNetwork();
        setText("netLabel", String(net2.chainId));
        setDot("dotNet", net2.chainId === CONFIG.CHAIN_ID);
        return net2.chainId === CONFIG.CHAIN_ID;
      }catch(e){
        logLine("Network switch failed:", e.message || e);
        return false;
      }
    }

    /**********************
     * Receipt / Polygonscan helpers
     **********************/
    function topic0FromEventSig(sig){ return ethers.utils.id(sig); }
    function topic1FromAddress(addr){
      return "0x" + addr.toLowerCase().replace(/^0x/,"").padStart(64,"0");
    }

    async function checkReceiptForEvent(txHash, eventSig, walletAddr){
      const receipt = await rpcProvider.getTransactionReceipt(txHash);
      if (!receipt) return { ok:false, reason:"NO_RECEIPT_YET" };

      const t0 = topic0FromEventSig(eventSig);
      const t1 = topic1FromAddress(walletAddr);
      for (const log of receipt.logs){
        if (log.topics && log.topics.length >= 2 && log.topics[0].toLowerCase() === t0.toLowerCase()){
          if (log.topics[1].toLowerCase() === t1.toLowerCase()){
            return { ok:true, receipt, matchedLog: log };
          }
        }
      }
      return { ok:false, reason:"EVENT_NOT_FOUND", receipt };
    }

    function todayUtcRange(){
      const now = Math.floor(Date.now()/1000);
      const start = Math.floor(now/86400)*86400;
      const end = start + 86400 - 1;
      return { start, end };
    }

    async function polygonscanTxList(address, startTsSec, endTsSec){
      if (!CONFIG.POLYGONSCAN_API_KEY) throw new Error("POLYGONSCAN_KEY_MISSING");
      const base = "https://api.polygonscan.com/api";
      const url = new URL(base);
      url.searchParams.set("module","account");
      url.searchParams.set("action","txlist");
      url.searchParams.set("address", address);
      url.searchParams.set("startblock","0");
      url.searchParams.set("endblock","99999999");
      url.searchParams.set("sort","desc");
      url.searchParams.set("apikey", CONFIG.POLYGONSCAN_API_KEY);

      const r = await fetch(url.toString());
      const j = await r.json();
      if (j.status !== "1" && j.message !== "OK") throw new Error(j.result || "POLYGONSCAN_FAIL");
      const arr = Array.isArray(j.result) ? j.result : [];
      return arr.filter(tx => {
        const ts = Number(tx.timeStamp||0);
        return ts >= startTsSec && ts <= endTsSec;
      });
    }

    /**********************
     * UI updates
     **********************/
    function renderConfig(){
      document.getElementById("cfg").textContent = JSON.stringify(CONFIG, null, 2);
      document.getElementById("buyEventLabel").textContent = CONFIG.BUY_RECEIPT_EVENT;
    }

    function updateAllStatus(){
      const dayId = utcDayIdNow();
      setText("dayLabel", String(dayId));

      const state = getDayState(userAddr || "anon", dayId);

      // PNR
      setDot("dotPNR", !!state.pnr);
      setText("pnrLabel", state.pnr ? "Done" : "Not done");
      setText("pnrTx", state.pnrTx ? state.pnrTx : "‚Äî");

      // Buy
      setDot("dotBuy", !!state.buy);
      setText("buyLabel", state.buy ? "Done" : "Not done");
      setText("buyTx", state.buyTx ? state.buyTx : "‚Äî");

      // Liquidity
      setDot("dotLiq", !!state.liq);
      setText("liqLabel", state.liq ? "Done" : "Not done");
      setText("liqTx", state.liqTx ? state.liqTx : "‚Äî");

      // Kept today + confetti
      const kept = !!(state.pnr && state.buy && state.liq);
      setDot("dotKept", kept);
      setText("keptLabel", kept ? "Yes ‚úÖ" : "‚Äî");

      if (kept && !state.confetti){
        confettiOnce();
        setDayState(userAddr || "anon", dayId, { confetti:true });
      }

      // support
      const sup = getSupport(userAddr || "anon");
      if (sup?.value){
        setDot("dotSupport", true);
        setText("supportLabel", `Supporting: ${sup.value}`);
      } else {
        setDot("dotSupport", false);
        setText("supportLabel", "No support registered");
      }

      // enable/disable
      const connected = !!userAddr;
      document.getElementById("btnPnrClaim").disabled = !connected;
      document.getElementById("btnPnrCheck").disabled = !connected;
      document.getElementById("btnBuyCheck").disabled = !connected;
      document.getElementById("btnLiqCheck").disabled = !connected;
      document.getElementById("btnSaveSupport").disabled = !connected;

      const canAuto = connected && !!CONFIG.POLYGONSCAN_API_KEY;
      document.getElementById("btnBuyAuto").disabled = !canAuto;
      document.getElementById("btnLiqAuto").disabled = !canAuto;
    }

    /**********************
     * Actions
     **********************/
    async function postSignPayload({ user, dayId, expiresInSec }){
      const resp = await fetch(CONFIG.SIGN_ENDPOINT, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ user, dayId, expiresInSec })
      });
      const data = await resp.json().catch(()=> ({}));
      if (!resp.ok) throw new Error(data?.error || ("SIGN_HTTP_" + resp.status));
      return data;
    }

    async function pnrClaim(){
      if (!provider || !signer || !userAddr) throw new Error("Connect MetaMask first.");
      const okNet = await ensurePolygon();
      if (!okNet) throw new Error("Wrong network (need Polygon 137).");

      const dayId = utcDayIdNow();
      const expiresInSec = Number(document.getElementById("expInput").value || "900");

      logLine("Requesting signature payload‚Ä¶", { user: userAddr, dayId, expiresInSec });
      const payload = await postSignPayload({ user:userAddr, dayId, expiresInSec });

      // safety checks
      if (Number(payload.dayId) !== Number(dayId)) throw new Error(`DAYID_MISMATCH (client ${dayId} vs signer ${payload.dayId})`);
      const nowSec = Math.floor(Date.now()/1000);
      if (Number(payload.expiresAt) <= nowSec) throw new Error(`SIGNATURE_EXPIRED (expiresAt ${payload.expiresAt}, now ${nowSec})`);

      logLine("Signer payload:", payload);

      const c = new ethers.Contract(CONFIG.PNR_CONTRACT, PNR_ABI, signer);
      const tx = await c.claim(
        Number(payload.dayId),
        payload.videoIdBytes32,
        Number(payload.expiresAt),
        payload.sig
      );

      logLine("Tx sent:", tx.hash);
      const receipt = await tx.wait();
      logLine("Confirmed in block", receipt.blockNumber);

      setDayState(userAddr, dayId, { pnr:true, pnrTx: tx.hash });
      updateAllStatus();
    }

    async function pnrCheckLast(){
      const dayId = utcDayIdNow();
      const st = getDayState(userAddr, dayId);
      if (!st.pnrTx) { logLine("No stored PNR tx for today."); return; }

      const res = await checkReceiptForEvent(st.pnrTx, CONFIG.PNR_RECEIPT_EVENT, userAddr);
      if (res.ok){
        logLine("PNR verified ‚úÖ", CONFIG.PNR_RECEIPT_EVENT, "found in receipt logs.");
        setDayState(userAddr, dayId, { pnr:true });
      } else {
        logLine("PNR verify:", res.reason);
      }
      updateAllStatus();
    }

    async function buyCheckTx(txHash){
      if (!txHash || !txHash.startsWith("0x")) throw new Error("Paste a valid tx hash.");
      const dayId = utcDayIdNow();
      const res = await checkReceiptForEvent(txHash, CONFIG.BUY_RECEIPT_EVENT, userAddr);
      if (res.ok){
        logLine("Buy verified ‚úÖ", CONFIG.BUY_RECEIPT_EVENT, "found in receipt logs.");
        setDayState(userAddr, dayId, { buy:true, buyTx: txHash });
      } else {
        logLine("Buy verify:", res.reason);
      }
      updateAllStatus();
    }

    async function liqCheckTx(txHash){
      if (!txHash || !txHash.startsWith("0x")) throw new Error("Paste a valid tx hash.");
      const dayId = utcDayIdNow();
      const res = await checkReceiptForEvent(txHash, CONFIG.HUB_RECEIPT_EVENT, userAddr);
      if (res.ok){
        logLine("Liquidity verified ‚úÖ", CONFIG.HUB_RECEIPT_EVENT, "found in receipt logs.");
        setDayState(userAddr, dayId, { liq:true, liqTx: txHash });
      } else {
        logLine("Liquidity verify:", res.reason);
      }
      updateAllStatus();
    }

    async function buyAutoVerifyToday(){
      const { start, end } = todayUtcRange();
      const txs = await polygonscanTxList(userAddr, start, end);
      if (!txs.length) { logLine("Polygonscan: no tx found today."); return; }

      for (const tx of txs){
        try{
          const res = await checkReceiptForEvent(tx.hash, CONFIG.BUY_RECEIPT_EVENT, userAddr);
          if (res.ok){
            logLine("Auto-verified buy ‚úÖ tx:", tx.hash, "block:", tx.blockNumber);
            await buyCheckTx(tx.hash);
            return;
          }
        }catch(_){}
      }
      logLine("Auto-verify buy: no matching receipt event found in today's txs.");
    }

    async function liqAutoVerifyToday(){
      const { start, end } = todayUtcRange();
      const txs = await polygonscanTxList(userAddr, start, end);
      if (!txs.length) { logLine("Polygonscan: no tx found today."); return; }

      for (const tx of txs){
        try{
          const res = await checkReceiptForEvent(tx.hash, CONFIG.HUB_RECEIPT_EVENT, userAddr);
          if (res.ok){
            logLine("Auto-verified liquidity ‚úÖ tx:", tx.hash, "block:", tx.blockNumber);
            await liqCheckTx(tx.hash);
            return;
          }
        }catch(_){}
      }
      logLine("Auto-verify liquidity: no matching receipt event found in today's txs.");
    }

    /**********************
     * Wire buttons
     **********************/
    document.getElementById("btnConnect").onclick = async () => {
      try{
        if (!window.ethereum) { logLine("No wallet detected. Install MetaMask."); return; }
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        userAddr = await signer.getAddress();

        setText("addrLabel", userAddr.slice(0,6) + "‚Ä¶" + userAddr.slice(-4));
        setDot("dotWallet", true);

        await ensurePolygon();

        // RPC provider for receipt checks
        rpcProvider = new ethers.providers.JsonRpcProvider(CONFIG.RPC_URL);

        logLine("Connected as", userAddr);
        updateAllStatus();
      }catch(e){
        logLine("Connect error:", e.message || e);
        setDot("dotWallet", false);
      }
    };

    document.getElementById("btnResetDay").onclick = () => {
      const dayId = utcDayIdNow();
      localStorage.removeItem(keyDay(userAddr || "anon", dayId));
      logLine("Reset local receipts for dayId", dayId);
      updateAllStatus();
    };

    document.getElementById("btnPnrClaim").onclick = async () => {
      try { await pnrClaim(); } catch(e){ logLine("PNR claim failed:", e.message || e); }
    };
    document.getElementById("btnPnrCheck").onclick = async () => {
      try { await pnrCheckLast(); } catch(e){ logLine("PNR check failed:", e.message || e); }
    };

    document.getElementById("btnBuyOpen").onclick = () => window.open(CONFIG.BUYHELPER_URL, "_blank", "noopener");
    document.getElementById("btnLiqOpen").onclick = () => window.open(CONFIG.LIQUIDITY_URL, "_blank", "noopener");

    document.getElementById("btnBuyCheck").onclick = async () => {
      try{
        const tx = document.getElementById("buyTxInput").value.trim();
        await buyCheckTx(tx);
      }catch(e){ logLine("Buy check failed:", e.message || e); }
    };

    document.getElementById("btnLiqCheck").onclick = async () => {
      try{
        const tx = document.getElementById("liqTxInput").value.trim();
        await liqCheckTx(tx);
      }catch(e){ logLine("Liquidity check failed:", e.message || e); }
    };

    document.getElementById("btnBuyAuto").onclick = async () => {
      try{ await buyAutoVerifyToday(); } catch(e){ logLine("Auto-verify buy failed:", e.message || e); }
    };

    document.getElementById("btnLiqAuto").onclick = async () => {
      try{ await liqAutoVerifyToday(); } catch(e){ logLine("Auto-verify liquidity failed:", e.message || e); }
    };

    document.getElementById("btnSaveSupport").onclick = () => {
      const v = document.getElementById("rhythmSelect").value;
      setSupport(userAddr || "anon", v);
      logLine("Support saved:", v);
      updateAllStatus();
    };

    /**********************
     * Init
     **********************/
    (function init(){
      renderConfig();
      // defaults
      setText("netLabel","‚Äî");
      setText("addrLabel","‚Äî");
      setText("keptLabel","‚Äî");
      setText("pnrLabel","‚Äî");
      setText("buyLabel","‚Äî");
      setText("liqLabel","‚Äî");
      setText("supportLabel","‚Äî");
      // show "today" even before wallet
      setInterval(updateAllStatus, 2000);
      updateAllStatus();
    })();
  </script>
</body>
</html>
